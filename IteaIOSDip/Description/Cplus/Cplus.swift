//
//  Cplus.swift
//  IteaIOSDip
//
//  Created by alexey sorochan on 11/29/19.
//  Copyright © 2019 alexey sorochan. All rights reserved.
//

func cplusTypeDescription() -> CoursesTypeDescription {
    let cplus = CoursesTypeDescription()
    cplus.typeDescription = """
        Курсы программирования на C++
        — комплексная программа обучения одному из самых популярных и мощных языков программирования, С ++. Обучение состоит из взаимосвязанных этапов, после которых ты овладеешь основами программирования на базовом и продвинутом уровнях. Программа C ++ предусматривает получение hard skills и soft skills, необходимых Junior-специалисту. Язык С ++ ( «си плюс плюс») широко используется при создании программного обеспечения: прикладных программ, драйверов, развлекательных, офисных приложений, приложений для встраиваемых устройств, операционных систем. Специалистов, которые знают программирование С ++, на современном IТ-рынке немного, поэтому востребованность в таких программистах стабильная. Преподаватели-практики помогут тебе стать профессионалом в программировании C++ и получить работу своей мечты.
    """
    cplus.typeLevelDescription = """
    •    Использовать основные структуры данных для разработки программ
    •    Использовать ООП-методологии для разработки программ
    •    Разрабатывать консольные приложения в операционной системе Linux
    •    Работать со стандартной библиотекой С++ и библиотекой Qt
    •    Создавать GUI-приложения
    •    Работать программистом C++ и в команде разработчиков, и на фрилансе
    •    Уметь разбивать задачи на отдельные процессы, эффективно планировать время на выполнение задач
    """
    return cplus
}

func cplusDescrioption() -> [CourseDescription] {
    let cplusBase = CourseDescription()
    cplusBase.courseDescriotion = """
    Курс состоит из 11 занятий общей длительностью в 36 академических часов. В курсе предусмотрено 11 лабораторных работ для самостоятельного усвоения материала. Основной задачей курса является обучение слушателей теоретическим основам объектно-ориентированного программирования, приемам разработки ПО, решения типичных задач программирования и разработки приложений на языке С++.
    """
    cplusBase.courseSkills = """
    Разрабатывать ПО на языке C++
    •    Выполнять математические расчеты, решать задачи и реализовывать типовые алгоритмы
    •    Разрабатывать консольные приложения в операционной системе Linux
    """
    cplusBase.courseProgram = """
    •    Немного истории
    ◦    Что такое язык программирования
    ◦    Машинные языки
    ◦    Низкоуровневые языки (язык ассемблера)
    ◦    Высокоуровневые языки
    ◦    Трансляторы
    ◦    Компиляция
    ◦    Интерпретация
    ◦    Парадигмы программирования
    ◦    Модульная парадигма программирования
    ◦    Функциональная парадигма программирования
    ◦    Обобщенная парадигма программирования
    ◦    Объектно ориентированная парадигма программирования
    ◦    История С++
    •    Основы GIT-системы контроля версии
    ◦    Что такое система контроля версии и что она решает
    ◦    Основные элементы git
    ◦    Что такое коммит
    ◦    Что такое ветка
    ◦    Способы создания репозитория. Виды сервисов, позволяющие создать удаленный репозиторий
    ◦    Базовые команды git
    ◦    Практика. Создания репозитория локально. Создания репозитория на удаленном сервере
    •    Состав языка С++
    ◦    Пример простой программы С++
    ◦    Базовые способы собрать приложение
    ◦    Алфавит языка
    ◦    Что такое лексемы
    ◦    Что такое идентификатор как важная составляющая программы
    ◦    Что такое ключевые слова
    ◦    Комментарии (однострочные, многострочные)
    ◦    Что такое литера. Виды литералов. И зачем они нужны в коде
    ◦    Чем отличаются строковый литерал от остальных типов литералов
    ◦    Что такое инструкции
    ◦    Что значит синтаксическая ошибка. Пример простой синтаксической ошибки
    ◦    Что такое семантическая ошибка. Пример семантической ошибки и возможные ее последствия
    •    Переменные и типы данных
    ◦    Что такое переменная. Синтаксис объявления переменной
    ◦    Тип данных. Что такое строгая типизация. Зачем переменной нужен тип данных
    ◦    Целочисленный тип данных
    ◦    Символьные типы
    ◦    Начиная с С++11, целочисленные типы с фиксированными размером, какие проблемы они решают
    ◦    Что такое алиас на тип данных. Пример с описанием typedef. Понимания типов size_t, time_t —  это просто алиас на встроенный тип
    ◦    Тип void как маркер разного контекста. Пример контекста использования этого типа
    ◦    Логический тип данных
    ◦    Вещественные типы данных. Возможные подводные камни представления в памяти
    ◦    Простой пример на ассемблере способа представления целочисленных типов и вещественных типов
    ◦    Способы объявления переменных. Инициализация переменных. Проблема неинициализированных переменных
    ◦    Оператор sizeof для получения размера переменных и типов
    ◦    Способы инициализации переменных до С++11 и универсальная инициализация начиная с С++11 как средство решения проблем старой инициализации
    ◦    Автоматический вывод типа. Ключевое слово auto и decltype
    ◦    Константы
    ◦    Способы объявления констант
    ◦    Что такое свертка констант. Пример С++-кода с объявлением констант и оптимизированного ассемблерного кода
    •    Основные операции С++
    ◦    Виды операторов (унарный, бинарный, тернарный). Их синтаксис
    ◦    Неявное преобразование при операторе присвоения. Что такое срезка. Что такое сужающее преобразование. Проблема знакового и беззнакового преобразования
    ◦    Явное преобразования типов (С-подход и С++-подход)
    ◦    Арифметические операции
    ◦    Проблема арифметических операций. Целочисленное деление на ноль, переполнение и т.д.
    ◦    Смешанные выражения. Приоритет операций
    ◦    Автоматический вывод типа как решение проблемы переполнения в арифметических выражениях
    ◦    Временная переменная как результат промежуточного вычисления выражения. Как выглядит временная переменная в сгенерированном ассемблерном коде (простое описание)
    ◦    Базовые понятия Rvalue и Lvalue
    ◦    Составной оператор
    ◦    Пост- и пре-инкремент и декремент. В чем отличие между пре- и пост- операцией
    ◦    Операторы отношения между операндами. Возможные подводные камни
    ◦    Логические операции
    ◦    Битовые операции. Что такое установка бита, что такое сброс бита. Что такое little-endian и big-endian. Что такое битовые маски, пример битовых масок до С++11 и начиная с С++11
    ◦    Описание разницы между логическим сравнением с применением логических операторов {|| &&} и битовыми операциями {| &}
    ◦    Арифметические операции, применимые к типу char и разница с выводом на поток символьного типа и целочисленного типа
    ◦    Целочисленный оператор «остаток от деления». Рассмотрения примера ошибочной путаницы между знаковыми и беззнаковыми типами на сгенерированном ассемблерном коде
    •    Операторы, управляющие ходом выполнения программы
    ◦    Условный оператор if. Пример возможных проблем с висячими else. Разные подходы с написаниям оператора if для избежания спагетти-кода
    ◦    Что такое область видимости. Что такое блок
    ◦    Оператор выбора switch. Проблема fall through. В чем отличие между оператором выбора switch и логическим оператором if
    ◦    Что такое compile time и run time-выражение. На примере case-веток оператора выбора switch
    ◦    Оператор цикла for. Способы объявления цикла for. Зачем нужен вечный цикл. Возможные проблемы знакового и беззнакового сравнения и их последствия
    ◦    Оператор цикла while
    ◦    Оператор цикла do while. Использования do while, для решения проблем с ветвлением кода с использованием оператора if
    ◦    Тернарный оператор
    ◦    Простое понимание точки следования на примере оператора запятой
    •    Массивы
    ◦    Что такое массив и в чем его преимущества
    ◦    Объявления массивов. Способы указания размера массива Инициализация массива. Возможные ошибки при инициализации массива
    ◦    Массив переменной длины как расширение компилятора. Флаг компиляции -pedantic
    ◦    Массив символов или строки. Способы объявления. Что такое нуль-терминальный символ. Возможные проблемы при инициализации символьного массива
    ◦    Доступ к элементам массива
    ◦    Что такое выход за границы массива. Что такое buffer overflow
    ◦    Циклы как способ обхода, обработки и вывода массива на экран
    ◦    Частые ошибки при выборе типа для переменной цикла при работе с массивом
    ◦    Размер массива. Как получить количество элементов массива
    ◦    С++11 range for как способ удобной работы с массивом. В чем отличие range for и других циклов и какие проблемы решает range for в отличии от других циклов
    ◦    Отличие символьного массива от других типов массивов. Как правильно обходить символьный массив в циклах. Как вывести символьный массив на экран. Как считывать символы введенные с клавиатуры в символьный массив и возможные проблемы
    ◦    Многомерные массивы. Примеры представления многомерного массива одномерным массивом
    •    Указатели
    ◦    Базовые понятия памяти стек
    ◦    Что такое локальные переменные и как переменные создаются на стеке. Что такое автоматическое управление памятью
    ◦    Базовое понятие указателя
    ◦    Объявление указателей
    ◦    Способы инициализации указателя. Что такое невалидный указатель. Что такое разыменования указателя и возможные проблемы. nullptr как правильный литерал для инициализации указателя. Что значит понятие «указатель на тип». Размер указателя, модели памяти разных ОС и платформ. Почему для указателя правильный тип есть void*
    ◦    Что такое константный указатель и указатель на const. Пример возможных ошибок
    ◦    Арифметика с указателями. Чем отличаются арифметика с указателями от арифметики с переменными
    ◦    Что общего между массивом и указателем. Как обходить массив с помощью указателя. Что означает указатель на элемент за последним элементом массива и зачем так делать
    •    Функции
    ◦    Что такое функция и какие она решает проблемы в коде
    ◦    Синтаксис функции
    ◦    Базовое понятие что такое объявление и определение функции. Пример отличия
    ◦    Что такое списки параметров. Способ вызова функции. Задание значения по умолчанию для параметра
    ◦    Возвращаемое значение из функции. auto как автоматический вывод возвращаемого значения. Проблемы при автоматическом выводе типа. Тип void как маркер невозвращаемого значения функции
    ◦    Передача параметров по значению
    ◦    Что такое фактические и формальные параметры
    ◦    Неправильное использования auto в качестве параметров функции и последующее расширения компиляторов
    ◦    Что такое глобальные переменные. Проблема сокрытия имен глобальных и локальных переменных
    ◦    Передача по указателю. Способ возврата нескольких значений с функции
    ◦    Что такое ссылки. В чем отличие ссылки от указателя
    ◦    Ссылка как часть интерфейса функции
    ◦    Какие проблемы решает ссылка в сравнении с указателем как параметр функции. Какие преимущества константной ссылки. Почему можно передавать Rvalue как аргумент константной ссылки
    ◦    Пример как сделать ссылку невалидной
    ◦    Стек и вызов функций
    ◦    Соглашение о вызове функций
    ◦    Массивы как параметры функции. Способы объявления массива как параметра функции и частые ошибки. Проблема получения количества элементов массива в функции
    ◦    Рекурсия. Inline-функции
    ◦    Что такое перегрузка функций. Что такое mangling имен функции на примере генерации ассемблерного кода
    ◦    Почему перегрузка недоступна в языке С. Простое описания ключевого слово extern «C» как пример описания перегрузки
    ◦    Что такое указатель на функцию и какие решает проблемы передача функции как параметр функции на примере алгоритма сортировки
    ◦    Базовые понятия что такое lambda как замена указателю на функцию. Что такое std::function
    ◦    Проблемы при возврате локальных переменных с функции по ссылке или указателю
    ◦    Снятие константности с аргумента использования std::const_cast
    •    Пространства имен
    ◦    Что такое пространства имен
    ◦    Что такое вложенные пространства имен
    ◦    Новые возможности объявления вложенных пространств имен в С++17
    •    Простые пользовательские типы данных
    ◦    Что такое структуры. Какие они решают проблемы
    ◦    Объявление структур
    ◦    Способы доступа к полям структуры
    ◦    Способы инициализации структур до С++11
    ◦    Инициализация структур начиная с С++11
    ◦    Размер структур. Что такое выравнивание структур. Что такое padding в структурах
    ◦    Неименованные структуры
    ◦    Struct binding С++17. Какие проблемы решает
    ◦    Что такое перечисления и какие оно решает проблемы
    ◦    Что такое unscoped-перечисления и какие у него проблемы
    ◦    Что такое scoped-перечисления, начиная с С++11 и какие он решает проблемы
    ◦    Что такое объединения. Какие он решает проблемы
    ◦    Что такое каламбур типов и как объединение помогает в преобразовании несовместимых типов
    •    Работа с динамической памятью
    ◦    Базовые понятия о моделях памяти. Их особенности и отличия
    ◦    Отличие работы со стековой памятью и динамической памятью (куча)
    ◦    Что такое менеджер памяти или почему динамическое выделение памяти такое дорогое
    ◦    Работа с динамической памятью, используя С-функции
    ◦    Работа с динамической памятью, используя С++-подход
    ◦    Возможные проблемы при работе с динамической памятью
    1.
    •    Классы и объекты (ООП)
    ◦    Базовые понятия ООП
    ◦    Что есть недостатком функционального программирования и какие задачи решает ООП
    ◦    Основные киты ООП
    ◦    Синтаксис объявления класса
    ◦    Что такое поля класса
    ◦    Создание объекта класса
    ◦    Уровни доступа в классе
    ◦    Способы объявления константных полей в классе до С++11 и после
    ◦    Что такое статические поля
    ◦    Что такое метод класса. Чем отличается метод от обычной функции
    ◦    Что такое this. Что такое соглашение о вызове thiscall
    ◦    Способы объявления методов класса. Чем отличаются определение метода внутри класса от определения за пределами класса
    ◦    Что такое константные методы и какие они решают проблемы. Ключевое слово mutable
    ◦    Что такое статические методы и чем они отличаються от обычных методов
    1.
    •    Конструкторы и деструкторы
    ◦    Что такое конструктор и какие он решает проблемы
    ◦    Виды конструкторов до С++11
    ◦    Список инициализации. Способ инициализации полей класса, начиная с С++11. Подводные камни при инициализации полей класса
    ◦    Зачем нужен конструктор копирования и оператор присваивания
    ◦    Что такое деструктор и какие он решает проблемы
    ◦    Правильная сигнатура для конструкторов и оператора присваивания
    ◦    Перегрузка конструкторов
    ◦    Порядок инициализации полей при создании объекта
    •    Наследование
    ◦    Что такое наследование и какие оно решает проблемы
    ◦    Виды наследования
    ◦    Чем является наследование (public-наследования)
    ◦    Расположение объектов в памяти при наследовании
    ◦    Порядок инициализации при наследовании. Подводные камни
    ◦    Порядок вызовов при разрушении объекта
    ◦    Shadowing-методы при наследовании
    ◦    Множественное наследование. В чем отличие от одиночного наследования. Подводные камни множественного наследования
    ◦    Неоднозначность вызова метода при множественном наследовании
    ◦    Проблема ромбового наследования
    ◦    Что такое виртуальное наследование и зачем оно нужно в контексте наследования
    ◦    Ключевое слово final
    •    Виртуальные функции
    ◦    Что такое полиморфизм
    ◦    Что такое виртуальная функция
    ◦    Что такое динамический и статический полиморфизм и как он реализуется в языке С++
    ◦    Ключевое слово override и какие он решает проблемы в контексте виртуальных функций
    ◦    Что такое виртуальный деструктор и зачем он нужен
    ◦    Что такое чисто виртуальные функции. Что такое абстрактный класс
    ◦    Что такое vtable и vtpr. На что они влияют
    •    Шаблоны
    ◦    Что такое шаблоны и обобщенное программирование
    ◦    Что общего между макросом и шаблоном. Какие проблемы макроса
    ◦    Шаблоны класса
    ◦    Что такое инстанцирование шаблона
    ◦    Проблема раздувания кода
    ◦    Параметры шаблона. Передача значения в качестве шаблонного аргумента
    ◦    Специализация. Частичная специализация. Явная специализация
    ◦    Шаблонные функции
    ◦    Шаблонный метод. Шаблонный конструктор. Какие задачи они позволяют решить
    ◦    Разница в вызове шаблонного класса и шаблонной функции
    ◦    Явная специализация шаблона функции
    •    Перегрузка операторов
    ◦    Что такое перегрузка операторов
    ◦    Когда стоит применять перегрузку операторов
    ◦    Какие операции разрешено перегружать
    ◦    В чем разница между перегрузкой оператора как методом класса и обычной функцией
    ◦    Базовые соглашения о перегрузке операторов
    ◦    Тонкости при перегрузке пре- и пост-инкремента и декремента
    ◦    Рекомендации по написанию интерфейса перегрузки операторов
    ◦    Особенности перегрузки вывода на поток
    •    Пространства имен
    ◦    Что такое пространства имен. Их применения. Какие они решают проблемы
    ◦    Что такое неименованные пространства имен, что общего между static и неименованными пространствами имен
    1.
    •    Базовые понятия о компиляции и системах сборки
    ◦    Что такое препроцессинг
    ◦    Что такое компиляция
    ◦    Что такое линковщик
    ◦    Виды компиляторов и их особенности
    ◦    Что такое раздельная компиляция
    ◦    Что такое заголовочный файл
    ◦    Что такое стражи
    ◦    Что такое библиотеки
    ◦    Система сборки Make
    ◦    CMake как генератор системы сборки

    """
    let cplusAdvanced = CourseDescription()
    cplusAdvanced.courseDescriotion = """
    Продвинутый курс C++ поможет усовершенствовать навыки ООП. Вы научитесь работать со стандартной библиотекой C++, освоите основные возможности библиотеки Qt, получите практический опыт разработки GUI-приложений. Мы обучим вас приемам разработки ПО, решениям типичных задач программирования и разработки GUI-приложений на языке С++ с помощью библиотеки Qt. Вы узнаете о контейнерах, алгоритмах и адаптерах, разберетесь в архитектуре приложений и базах данных, поработаете с многопоточностью и модульным тестированием ПО.
    """
    cplusAdvanced.courseSkills = """
    •    Усовершенствуете навыки объектно-ориентированного программирования, анализа и проектирования
    •    Работать со стандартной библиотекой С++ и библиотекой Qt
    •    Разрабатывать GUI-приложения
    •    Претендовать на получение высокооплачиваемой работы
    """
    cplusAdvanced.courseProgram = """
    •    Конструкторы/деструкторы
        1.    Правила генерации конструкторов до С++11
        2.    Что такое rvalue ссылки
        3.    Перемещающий конструктор и перемещающий оператор присвоения
        4.    Правила генерации конструкторов и операторов присваивания после С++11
        5.    Функция std::move. Неправильное применение функции std::move в качестве возвращаемого значения.
        6.    Разница между объявлением конструкторов и операторов присваивания как приватные методы и объявление их с помощью ключевого слова delete.
        7.    Зачем вообще нужно писать конструкторы и операторы присваивания как недоступные.
        8.    Важность объявления конструкторов с помощью  ключевого слова default.
        9.    Что такое delegating constructors.
        10.    Простое понимание что такое NRVO и RVO.
        11.    Проблемы влияния пользовательского конструктора на неявное преобразования типов. Ключевое слово explicit.
        12.    Reference-qualified методы класса.
     
        •    Статический полиморфизм
        1.    Более детальное понимание перегрузки функции. Ключевое понятие mangling и рассмотрение примера перегрузки на примере таблицы символов.
        2.    Шаблоны и шаблоны класса. Правила вывода типов для шаблонных параметров. Trailing return type.
        3.    Проблематика шаблонов. Проблемы инстанцирования. Способы явного инстанцирования.
        4.    Пример написания класса array, как аналог замены встроенного статического массива.
     
        •    Динамический полиморфизм
        1.    Особенности работы с динамическим полиморфизмом (virtual functions).
        2.    Важные нововведения, начиная с С++11 для безопасной работы с динамическим полиморфизмом.
        3.    Ключевое слово final в контексте виртуальных функций.
        4.    Аргумент по умолчанию и какие он скрывает проблемы в контексте виртуальных функций.
        5.    Структура type_info.
        6.    Когда именно полезен динамический полиморфизм.
     
        •    Более сложные применение шаблонов
        1.    Структура std::enable_if, зачем это может пригодиться. Элегантная замена сложности std::enable_if, начиная с С++17.
        2.    Метапрограммирование, рассмотрение заголовочного файла <type_traits> как способ получения метаинформации о типе. Его применения на примере простого шаблона.
        3.    Функция std::forward
        4.    Шаблоны с переменным числом параметров, понятие свертки.
        5.    Шаблонные конструкторы.
        6.    Вспомогательные шаблоны std::pair, шаблон std::tuple. Какие проблемы они решают .
     
        •    Написание библиотек на языке С++
        1.    Что такое разделяемые библиотеки.
        2.    Что такое статические библиотеки.
        3.    Разница в написании статических и динамических библиотек.
        4.    Пример написания двух видов библиотек.
        5.    Написание С++ библиотеки для подключения ее в С код и С++ код.
        6.    Возможные проблемы при написании библиотек.
        7.    Раздельная компиляция (многомодульность) и линковка.
     
        •    Вывод типа в С++ (type deduction)
        1.    Вывод типа с помощью ключевого слова auto: такой ли тип на самом деле?
        2.    Ключевое слово decltype.
        3.    Константные ссылки как средство пролонгации времени жизни объекта и подводные камни.
     
        •    Исключительные ситуации
        1.    Простое понимание исключительных ситуаций. Что такое раскрутка стека.
        2.    Ключевое слово noexcept. Его особенности.
        3.    Висячие ссылки и висячие указатели.
        4.    Исключительные ситуации в конструкторе и деструкторе.
        5.    noexcept деструкторы и конструкторы.
        6.    Нужны ли исключительные ситуации. то такое обработка ошибок в стиле С, нужна ли она и какие ее преимущества в сравнении с исключительными ситуациями.
     
        •     Умные указатели
        1.    Паттерн проектирования RAII.
        2.    Проблемы при использовании С-подхода динамического выделения памяти для объектов.
        3.    Что такое менеджер памяти и простое понимание выделения памяти.
        4.    Виды умных указателей. Какую проблему они решают.
        5.    Зачем нужны вспомогательные функции (make_unique и т.д.). Какую проблематику они решают.
        6.    Всегда ли стоит применять умные указатели, возможные проблемы производительности.
        7.    std::static_pointer_cast, std::dynamic_pointer_cast. В чем их отличие от static_cast и dynamic_cast.
        8.    Стоит ли проверять созданные умные указатели на nullptr. Когда умные указатели кидают исключения, а когда возвращают nullptr.
     
        •    Введение в STL
        1.    Что такое STL.
        2.    Немного о структуре STL.
        3.    Стоит ли знать всю библиотеку STL.
     
        •    Контейнеры в библиотеке STL
        1.    Последовательные контейнеры. Виды последовательных контейнеров, их отличие. Особенности работы с каждым из контейнеров. Рассмотрение основного функционала последовательных контейнеров.
        2.    Ассоциативные контейнеры. Виды ассоциативных контейнеров, их основные отличия. Особенности работы. Рассмотрение основного функционала ассоциативных контейнеров.
        3.    Какие задачи решают последовательные контейнеры и ассоциативные контейнеры.
        4.    В каких случаях не стоит применять контейнеры. Накладные расходы на применения контейнеров.
        5.    Возможные подводные камни работы как с последовательными, так и с ассоциативными контейнерами.
        6.    Классы адаптеры контейнеров. Виды и их особенности.
        7.    Что такое аллокатор в качестве параметра контейнера. огда стоит писать свой аллокатор, а когда нет.
     
        •    Класс std::string
        1.    Рассмотрение основных возможностей класса std::string. Ошибки при создании и инициализации класса std::string.
        2.    Рассмотрения основных методов работы с классом std::string.
     
        •    Итераторы
        1.    Виды итераторов.
        2.    Применение итераторов для каждого вида контейнера.
        3.    Способ работы с итераторами.
        4.    Вспомогательные функции для работы с итераторами.
        5.    Что означает begin-итератор  и end-итератор.
        6.    Range for C++ как элегантный способ обхода контейнеров.
     
        •    Алгоритмы STL
        1.    Виды алгоритмов.
        2.    Рассмотрение самых часто используемых алгоритмов.
        3.    Итераторы как клей между контейнером и алгоритмом.
        4.    Все ли виды алгоритмы применимы ко всем типам контейнеров. Что нужно понимать в интерфейсе алгоритма.
        5.    Преимущества применения методов контейнеров над алгоритмами.
        6.    Преимущества применения алгоритмов над методами контейнеров.
     
        •    Компаратор
        1.    Что такое компаратор и его специфика применения в алгоритмах и некоторых контейнерах.
        2.    Что такое указатель на функцию.
        3.    Что такое функциональный объект.
        4.    Описание функции std::bind
        5.    Что такое лямбда и что общего между функциональным объектом. Что такое список захвата и зачем он нужен. Особенности захвата переменных. Ключевое слово mutable и его применение к захваченным параметрам лямбды. Как передать лямбду в С-функцию. Отличие лямбды в С++11 и C++14.
        6.    Способ генерации лямбды-функции. Типичные ошибки в написании лямбды.
        7.    Класс std::function.
     
        •    Процессы и потоки
        1.    Что такое процесс. Описание работы процесса, выделение памяти, и связанные с ним расходы.
        2.    Что такое поток. Проблемы связанные с многопоточностью
        3.    Что такое планировщик.
     
        •    Потоки в С++
        1.    std::thread и способы работы. Передача параметров в потоки. Проблемы, связанные с классом std::thread. Что такое join и detach.
        2.    Что такое асинхронное выполнение потока и синхронное выполнение.
        3.    std::async. Какие его преимущества в сравнении с std::thread. Параметры при создании std::async.
        4.    Что такое std::future.
        5.    Что такое разделяемые данные. Стоит ли использовать подход «разделение данных».
        6.    Ошибочное понимание volatile-переменных в контексте потоков. Что такое барьеры памяти. Класс std::atomic, для чего он нужен, связанные с ним накладные расходы.
        7.    Ошибочное понимание std::shared_ptr в многопоточном программировании.
        8.    Что такое race condition и data race, причины их получения.
        9.    Объекты синхронизации потоков, доступных в стандартной библиотеке.
        10.    Что такое дедлок и механизмы его решения в стандартной библиотеке.
        11.    std::promise: что это такое. Его применение в контексте многопоточности. std::future + std::promise vs conditional variable.
        12.    Исключительные ситуации в потоках.
        13.    Что такое пул потоков и какие он решает проблемы.
     
        •    Сетевое программирование
        1.    Что такое сетевое программирование.
        2.    Виды часто используемых протоколов. Что такое TCP и UDP протоколы. Когда их стоит применять.
        3.    Что такое сокеты, их виды и применение.
        4.    Что такое межпроцессорное взаимодействия (IPC). Зачем нужно межпроцессорное взаимодействие. Какие оно решает проблемы. Рассмотрение часто используемых подходов IPC.
     
        •     Введение в Qt
        1.    Meta object compiler.
        2.    Сигналы и слоты.
        3.    QObject.
        4.    Базовая работа с виджетами.
        5.    Event loop.
        6.    Структура фреймворка.
     
        •    Введение в QML
        1.    Структура QML компонентов.
        2.    Компоненты QtObject, Item.
        3.    Базовые графические компоненты.
        4.    Best practices в QML.
        5.    Взаимодействие C++ & QML.
        6.    - Q_PROPERTY.
        7.    - Q_INVOKABLE.
        8.    Компоненты ListView, GridView.
        9.    Кастомизация компонентов.
        10.    Attached properties.
        11.    Scalability-приложения.
        12.    Сигналы/cлоты в QML.
        13.    Свойства, алиасы.
        14.    Регистрация своих классов в метасистеме.
     
        •     Model View в Qt
        1.    Понятие модели, их виды.
        2.    Понятие делегата.
        3.    Понятие роли.
        4.    Понятие view, их виды.
        5.    Реализация своей модели, её регистрация, базовые методы QAbstractListModel.
        6.    Создание кастомных компонентов-делегатов с использованием ролей.
        7.    qmldir, разбивка приложения на модули.
        8.    Использование стилей в QML.
        9.    QVariant.
     
        •    Работа с базами данных в Qt
        1.    Подключение к базе данных.
        2.    Классы QDir, QStandardPaths.
        3.    Выполнение SQL запросов.
        4.    Создание SQL-таблиц.
        5.    Обработка ошибок.
        6.    Привязка значений.
        7.    QVariantList.
        8.    Qt контейнеры, их преимущества и недостатки.
        9.    Copy-on-write.
        10.    Java style iterators vs stl style iterators.
     
        •    Многопоточность в Qt
        1.    Сравнение C++ потоков и многопоточности в Qt.
        2.    Многопоточность на сигналах и слотах.
        3.    QEventLoop.
        4.    QThread.
        5.    QtConcurrent.

    """
    return [cplusBase, cplusAdvanced]
}
